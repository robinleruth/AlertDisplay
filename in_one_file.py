#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('app/__init__.py', b'')
    __stickytape_write_module('app/domain/__init__.py', b'')
    __stickytape_write_module('app/domain/services/__init__.py', b'')
    __stickytape_write_module('app/domain/services/task_service.py', b'import asyncio\nimport datetime as dt\nimport queue\nfrom typing import List\n\nfrom app.domain.model.alert import Alert\nfrom app.domain.services.cron.cron_service import CronService\nfrom app.domain.services.parser.parser import Parser\nfrom app.domain.services.task_store import TaskStore\nfrom app.infrastructure.config import app_config\nfrom app.infrastructure.connector.db_task_store import DbTaskStore\nfrom app.infrastructure.db import Cron\nfrom app.infrastructure.log import logger\nfrom app.interface.gui.alert_window import AlertWindow\n\n\nclass TaskService:\n    sync_queue: queue.Queue\n    async_queue: asyncio.Queue\n    pending: asyncio.Queue\n    parser: Parser\n    task_store: TaskStore\n    cron_service: CronService\n\n    def __init__(self, q, aq) -> None:\n        self.sync_queue = q\n        self.async_queue = aq\n        self.pending = asyncio.Queue()\n        self.parser = Parser()\n        self.loop = asyncio.get_event_loop()\n        self.task_store = DbTaskStore()\n        self.cron_service = CronService()\n\n        self.loop.create_task(self.schedule_all_from_db())\n\n    async def wait(self):\n        logger.info("waiting for messages in queue")\n        message = await self.async_queue.get()\n        logger.info("Message received : {}".format(message))\n        await self.pending.put(message)\n\n    def create_alert(self, time: dt.datetime, message: str):\n        alert: Alert = Alert(None, message, time.strftime(app_config.TIME_FORMAT))\n        alert = self.task_store.put(alert)\n        logger.info("Creating alert {}".format(alert))\n        self.sync_queue.put(alert)\n        self.loop.create_task(\n            self.run_at(dt.datetime.strptime(alert.time, app_config.TIME_FORMAT), self.display_alert(alert)))\n\n    async def process_messages(self):\n        logger.info("processing messages : {}".format(self.pending.qsize()))\n        while not self.pending.empty():\n            r = await self.pending.get()\n            if self.cron_service.is_cron(r[0]):\n                self.cron_service.put(r[1], r[0])\n            time = self.parser.parse(r[0])\n            self.create_alert(time, r[1])\n            # alert: Alert = Alert(None, r[1], time.strftime(\'%Y-%m-%d %H-%M-%S\'))\n            # alert = self.task_store.put(alert)\n            # self.sync_queue.put(alert)\n            # self.loop.create_task(\n            #     self.run_at(dt.datetime.strptime(alert.time, \'%Y-%m-%d %H-%M-%S\'), self.display_alert(alert)))\n\n    @staticmethod\n    async def wait_until(d: dt.datetime):\n        now = dt.datetime.now()\n        await asyncio.sleep((d - now).total_seconds())\n\n    async def run_at(self, d: dt.datetime, coro):\n        await self.wait_until(d)\n        return await coro\n\n    async def display_alert(self, alert: Alert):\n        logger.info(\'Displaying alert\'.format(alert))\n        # remove from db\n        self.task_store.remove_one(alert.id)\n        # send message to queue to remove it from main ui\n        self.sync_queue.put(alert)\n        # start gui for Alert\n        AlertWindow(alert).start()\n        if self.cron_service.cron_in_db(alert.message):\n            logger.info("Alert is cron, rescheduling")\n            time = self.cron_service.get_next_time(alert.message)\n            self.create_alert(time, alert.message)\n\n    async def schedule_all_from_db(self):\n        alerts = self.task_store.get_all()\n        for alert in alerts:\n            self.sync_queue.put(alert)\n            if dt.datetime.strptime(alert.time, app_config.TIME_FORMAT) < dt.datetime.now():\n                await self.display_alert(alert)\n            else:\n                self.loop.create_task(\n                    self.run_at(dt.datetime.strptime(alert.time, app_config.TIME_FORMAT), self.display_alert(alert)))\n\n        crons: List[Cron] = self.cron_service.get_all()\n        for cron in crons:\n            time = self.cron_service.get_next_time(cron.message)\n            if not self.task_store.alert_is_in_db(cron.message, time.strftime(app_config.TIME_FORMAT)):\n                self.create_alert(time, cron.message)\n            else:\n                logger.info("Alert already in db : {} - {}".format(cron.message, time.strftime(app_config.TIME_FORMAT)))\n')
    __stickytape_write_module('app/domain/model/__init__.py', b'')
    __stickytape_write_module('app/domain/model/alert.py', b'from dataclasses import dataclass\n\n\n@dataclass\nclass Alert:\n    id: int\n    message: str\n    time: str\n')
    __stickytape_write_module('app/domain/services/cron/__init__.py', b'')
    __stickytape_write_module('app/domain/services/cron/cron_service.py', b"import datetime as dt\nfrom typing import List\n\nfrom app.domain.services.cron.cron_store import CronStore\nfrom app.domain.services.crontab import CronTab\nfrom app.domain.services.parser.cron_parser import CronParser\nfrom app.infrastructure.connector.db_cron_store import DbCronStore\nfrom app.infrastructure.db.cron import Cron\n\n\nclass CronService:\n    cron_store: CronStore\n    cron_parser: CronParser\n\n    def __init__(self):\n        self.cron_store = DbCronStore()\n        self.cron_parser = CronParser()\n\n    def get_all(self) -> List[Cron]:\n        return self.cron_store.get_all()\n\n    def remove_one(self, _id: int):\n        self.cron_store.remove_one(_id)\n\n    def put(self, message: str, cron: str) -> Cron:\n        return self.cron_store.put(message, cron)\n\n    def cron_in_db(self, message: str) -> bool:\n        return self.cron_store.is_cron(message)\n\n    @staticmethod\n    def is_cron(time: str) -> bool:\n        try:\n            c = CronTab(time)\n            # c.next()\n            return True\n        except ValueError:\n            return False\n\n    def get_next_time(self, message) -> dt.datetime:\n        cron = self.cron_store.get_one(message)\n        return self.cron_parser.parse(cron['cron'])\n")
    __stickytape_write_module('app/domain/services/cron/cron_store.py', b'from abc import ABCMeta, abstractmethod\nfrom typing import List\n\nfrom app.infrastructure.db.cron import Cron\n\n\nclass CronStore(metaclass=ABCMeta):\n    @abstractmethod\n    def get_all(self) -> List[Cron]:\n        pass\n\n    @abstractmethod\n    def remove_one(self, _id: int):\n        pass\n\n    @abstractmethod\n    def put(self, message: str, cron: str) -> Cron:\n        pass\n\n    @abstractmethod\n    def is_cron(self, message: str) -> bool:\n        pass\n\n    @abstractmethod\n    def get_one(self, message: str):\n        pass\n')
    __stickytape_write_module('app/infrastructure/__init__.py', b'')
    __stickytape_write_module('app/infrastructure/db/__init__.py', b'from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.orm import scoped_session\n\nfrom app.infrastructure.config import app_config\n\n\nBase = declarative_base()\n\n# pool_pre_ping=True as argument if needed\nengine = create_engine(app_config.SQL_URI)\nSession = scoped_session(sessionmaker(bind=engine,\n                                      autocommit=False,\n                                      autoflush=True))\n\n# from .log import Log\nfrom .alert import DbAlert\nfrom .cron import Cron\nBase.metadata.create_all(engine)\n')
    __stickytape_write_module('app/infrastructure/config.py', b"import os\n\n# assert 'APP_ENV' in os.environ, 'MAKE SURE TO SET AN ENVIRONMENT'\nbasedir = os.path.abspath(os.path.dirname(__file__))\nbasedir = os.path.split(basedir)[0]\n\n\nclass Config:\n    PORT = 8080\n    SECRET_KEY = os.environ.get('SECRET', 'secret')\n    SQL_URI = 'sqlite:///app.db'\n    BASEDIR = basedir\n    LOG_FOLDER = os.path.join(BASEDIR, 'logs')\n    LOG_FILENAME = 'app.log'\n    LOG_FILE_PATH = os.path.join(LOG_FOLDER, LOG_FILENAME)\n    LOGGER_NAME = 'logger'\n    TIME_FORMAT = r'%Y-%m-%d %H:%M:%S'\n    STATIC = os.path.join(basedir, 'static')\n\n\nclass TestConfig(Config):\n    SQL_URI = 'sqlite:///test.db'\n\n\n# env = os.environ['APP_ENV'].upper()\n# if env == 'TEST':\n#     app_config = TestConfig\n# elif env == 'PRD':\n#     app_config = DockerConfig\n# else:\n#     app_config = Config\napp_config = Config\n#\n# print(app_config)\n#")
    __stickytape_write_module('app/infrastructure/db/alert.py', b"from sqlalchemy import Column, Integer, String\n\nfrom . import Base\n\n\nclass DbAlert(Base):\n    __tablename__ = 'alerts'\n\n    id = Column(Integer, primary_key=True)\n    message = Column(String)\n    time = Column(String)\n\n    @property\n    def serialize(self):\n        return {\n            'id': self.id,\n            'message': self.message,\n            'time': self.time\n        }\n")
    __stickytape_write_module('app/infrastructure/db/cron.py', b"from sqlalchemy import Column, Integer, String\n\nfrom . import Base\n\n\nclass Cron(Base):\n    __tablename__ = 'cron'\n\n    id = Column(Integer, primary_key=True)\n    message = Column(String)\n    cron = Column(String)\n\n    @property\n    def serialize(self):\n        return {\n            'id': self.id,\n            'message': self.message,\n            'cron': self.cron\n        }\n")
    __stickytape_write_module('app/domain/services/crontab/__init__.py', b"\nfrom ._crontab import CronTab\n\n__all__ = ['CronTab']\n")
    __stickytape_write_module('app/domain/services/crontab/_crontab.py', b'\n\'\'\'\ncrontab.py\n\nWritten July 15, 2011 by Josiah Carlson\nCopyright 2011-2020 Josiah Carlson\nReleased under the GNU LGPL v2.1 and v3\navailable:\nhttp://www.gnu.org/licenses/old-licenses/lgpl-2.1.html\nhttp://www.gnu.org/licenses/lgpl.html\n\nOther licenses may be available upon request.\n\n\'\'\'\n\nfrom collections import namedtuple\nfrom datetime import datetime, timedelta\nimport random\nimport sys\nimport warnings\n\n_ranges = [\n    (0, 59),\n    (0, 59),\n    (0, 23),\n    (1, 31),\n    (1, 12),\n    (0, 6),\n    (1970, 2099),\n]\n\nENTRIES = len(_ranges)\nSECOND_OFFSET, MINUTE_OFFSET, HOUR_OFFSET, DAY_OFFSET, MONTH_OFFSET, WEEK_OFFSET, YEAR_OFFSET = range(ENTRIES)\n\n_attribute = [\n    \'second\',\n    \'minute\',\n    \'hour\',\n    \'day\',\n    \'month\',\n    \'isoweekday\',\n    \'year\'\n]\n_alternate = {\n    MONTH_OFFSET: {\'jan\': 1, \'feb\': 2, \'mar\': 3, \'apr\': 4, \'may\': 5, \'jun\': 6,\n        \'jul\': 7, \'aug\': 8, \'sep\': 9, \'oct\': 10, \'nov\':11, \'dec\':12},\n    WEEK_OFFSET: {\'sun\': 0, \'mon\': 1, \'tue\': 2, \'wed\': 3, \'thu\': 4, \'fri\': 5,\n        \'sat\': 6},\n}\n_aliases = {\n    \'@yearly\':  \'0 0 1 1 *\',\n    \'@annually\':  \'0 0 1 1 *\',\n    \'@monthly\': \'0 0 1 * *\',\n    \'@weekly\':  \'0 0 * * 0\',\n    \'@daily\':   \'0 0 * * *\',\n    \'@hourly\':  \'0 * * * *\',\n}\n\nWARNING_CHANGE_MESSAGE = \'\'\'\\\nVersion 0.22.0+ of crontab will use datetime.utcnow() and\ndatetime.utcfromtimestamp() instead of datetime.now() and\ndatetime.fromtimestamp() as was previous. This had been a bug, which will be\nremedied. If you would like to keep the *old* behavior:\n`ct.next(..., default_utc=False)` . If you want to use the new behavior *now*:\n`ct.next(..., default_utc=True)`. If you pass a datetime object with a tzinfo\nattribute that is not None, timezones will *just work* to the best of their\nability. There are tests...\'\'\'\n\n\nif sys.version_info >= (3, 0):\n    _number_types = (int, float)\n    xrange = range\nelse:\n    _number_types = (int, long, float)\n\nSECOND = timedelta(seconds=1)\nMINUTE = timedelta(minutes=1)\nHOUR = timedelta(hours=1)\nDAY = timedelta(days=1)\nWEEK = timedelta(days=7)\nMONTH = timedelta(days=28)\nYEAR = timedelta(days=365)\n\nWARN_CHANGE = object()\n\n# find the next scheduled time\ndef _end_of_month(dt):\n    ndt = dt + DAY\n    while dt.month == ndt.month:\n        ndt += DAY\n    return ndt.replace(day=1) - DAY\n\ndef _month_incr(dt, m):\n    odt = dt\n    dt += MONTH\n    while dt.month == odt.month:\n        dt += DAY\n    # get to the first of next month, let the backtracking handle it\n    dt = dt.replace(day=1)\n    return dt - odt\n\ndef _year_incr(dt, m):\n    # simple leapyear stuff works for 1970-2099 :)\n    mod = dt.year % 4\n    if mod == 0 and (dt.month, dt.day) < (2, 29):\n        return YEAR + DAY\n    if mod == 3 and (dt.month, dt.day) > (2, 29):\n        return YEAR + DAY\n    return YEAR\n\n_increments = [\n    lambda *a: SECOND,\n    lambda *a: MINUTE,\n    lambda *a: HOUR,\n    lambda *a: DAY,\n    _month_incr,\n    lambda *a: DAY,\n    _year_incr,\n    lambda dt,x: dt.replace(second=0),\n    lambda dt,x: dt.replace(minute=0),\n    lambda dt,x: dt.replace(hour=0),\n    lambda dt,x: dt.replace(day=1) if x > DAY else dt,\n    lambda dt,x: dt.replace(month=1) if x > DAY else dt,\n    lambda dt,x: dt,\n]\n\n# find the previously scheduled time\ndef _day_decr(dt, m):\n    if m.day.input != \'l\':\n        return -DAY\n    odt = dt\n    ndt = dt = dt - DAY\n    while dt.month == ndt.month:\n        dt -= DAY\n    return dt - odt\n\ndef _month_decr(dt, m):\n    odt = dt\n    # get to the last day of last month, let the backtracking handle it\n    dt = dt.replace(day=1) - DAY\n    return dt - odt\n\ndef _year_decr(dt, m):\n    # simple leapyear stuff works for 1970-2099 :)\n    mod = dt.year % 4\n    if mod == 0 and (dt.month, dt.day) > (2, 29):\n        return -(YEAR + DAY)\n    if mod == 1 and (dt.month, dt.day) < (2, 29):\n        return -(YEAR + DAY)\n    return -YEAR\n\ndef _day_decr_reset(dt, x):\n    if x >= -DAY:\n        return dt\n    cur = dt.month\n    while dt.month == cur:\n        dt += DAY\n    return dt - DAY\n\n_decrements = [\n    lambda *a: -SECOND,\n    lambda *a: -MINUTE,\n    lambda *a: -HOUR,\n    _day_decr,\n    _month_decr,\n    lambda *a: -DAY,\n    _year_decr,\n    lambda dt,x: dt.replace(second=59),\n    lambda dt,x: dt.replace(minute=59),\n    lambda dt,x: dt.replace(hour=23),\n    _day_decr_reset,\n    lambda dt,x: dt.replace(month=12) if x < -DAY else dt,\n    lambda dt,x: dt,\n    _year_decr,\n]\n\nMatcher = namedtuple(\'Matcher\', \'second, minute, hour, day, month, weekday, year\')\n\ndef _assert(condition, message, *args):\n    if not condition:\n        raise ValueError(message%args)\n\nclass _Matcher(object):\n    __slots__ = \'allowed\', \'end\', \'any\', \'input\', \'which\', \'split\', \'loop\'\n    def __init__(self, which, entry, loop=False):\n        """\n        input:\n            `which` - index into the increment / validation lookup tables\n            `entry` - the value of the column\n            `loop` - do we loop when we validate / construct counts\n                     (turning 55-5,1 -> 0,1,2,3,4,5,55,56,57,58,59 in a "minutes" column)\n        """\n        _assert(0 <= which <= YEAR_OFFSET,\n            "improper number of cron entries specified")\n        self.input = entry.lower()\n        self.split = self.input.split(\',\')\n        self.which = which\n        self.allowed = set()\n        self.end = None\n        self.any = \'*\' in self.split or \'?\' in self.split\n        self.loop = loop\n\n        for it in self.split:\n            al, en = self._parse_crontab(which, it)\n            if al is not None:\n                self.allowed.update(al)\n            self.end = en\n        _assert(self.end is not None,\n            "improper item specification: %r", entry.lower()\n        )\n        self.allowed = frozenset(self.allowed)\n\n    def __call__(self, v, dt):\n        for i, x in enumerate(self.split):\n            if x == \'l\':\n                if v == _end_of_month(dt).day:\n                    return True\n\n            elif x.startswith(\'l\'):\n                # We have to do this in here, otherwise we can end up, for\n                # example, accepting *any* Friday instead of the *last* Friday.\n                if dt.month == (dt + WEEK).month:\n                    continue\n\n                x = x[1:]\n                if x.isdigit():\n                    x = int(x) if x != \'7\' else 0\n                    if v == x:\n                        return True\n                    continue\n\n                start, end = map(int, x.partition(\'-\')[::2])\n                allowed = set(range(start, end+1))\n                if 7 in allowed:\n                    allowed.add(0)\n                if v in allowed:\n                    return True\n\n        return self.any or v in self.allowed\n\n    def __lt__(self, other):\n        if self.any:\n            return self.end < other\n        return all(item < other for item in self.allowed)\n\n    def __gt__(self, other):\n        if self.any:\n            return _ranges[self.which][0] > other\n        return all(item > other for item in self.allowed)\n\n    def __eq__(self, other):\n        if self.any:\n            return other.any\n        return self.allowed == other.allowed\n\n    def __hash__(self):\n        return hash((self.any, self.allowed))\n\n    def _parse_crontab(self, which, entry):\n        \'\'\'\n        This parses a single crontab field and returns the data necessary for\n        this matcher to accept the proper values.\n\n        See the README for information about what is accepted.\n        \'\'\'\n\n        # this handles day of week/month abbreviations\n        def _fix(it):\n            if which in _alternate and not it.isdigit():\n                if it in _alternate[which]:\n                    return _alternate[which][it]\n            _assert(it.isdigit(),\n                "invalid range specifier: %r (%r)", it, entry)\n            it = int(it, 10)\n            _assert(_start <= it <= _end_limit,\n                "item value %r out of range [%r, %r]",\n                it, _start, _end_limit)\n            return it\n\n        # this handles individual items/ranges\n        def _parse_piece(it):\n            if \'-\' in it:\n                start, end = map(_fix, it.split(\'-\'))\n                # Allow "sat-sun"\n                if which in (DAY_OFFSET, WEEK_OFFSET) and end == 0:\n                    end = 7\n            elif it == \'*\':\n                start = _start\n                end = _end\n            else:\n                start = _fix(it)\n                end = _end\n                if increment is None:\n                    return set([start])\n\n            _assert(_start <= start <= _end_limit,\n                "%s range start value %r out of range [%r, %r]",\n                _attribute[which], start, _start, _end_limit)\n            _assert(_start <= end <= _end_limit,\n                "%s range end value %r out of range [%r, %r]",\n                _attribute[which], end, _start, _end_limit)\n            if not self.loop:\n                _assert(start <= end,\n                    "%s range start value %r > end value %r",\n                    _attribute[which], start, end)\n\n            if increment and not self.loop:\n                next_value = start + increment\n                _assert(next_value <= _end_limit,\n                        "first next value %r is out of range [%r, %r]",\n                        next_value, start, _end_limit)\n\n            if start <= end:\n                return set(range(start, end+1, increment or 1))\n\n            right = set(range(end, _end_limit + 1, increment or 1))\n            first = max(right, default=end + (increment or 1)) % _end_limit\n            return set(range(first, start+1, increment or 1)) | right\n\n        _start, _end = _ranges[which]\n        _end_limit = _end\n        # wildcards\n        if entry in (\'*\', \'?\'):\n            if entry == \'?\':\n                _assert(which in (DAY_OFFSET, WEEK_OFFSET),\n                    "cannot use \'?\' in the %r field", _attribute[which])\n            return None, _end\n\n        # last day of the month\n        if entry == \'l\':\n            _assert(which == DAY_OFFSET,\n                "you can only specify a bare \'L\' in the \'day\' field")\n            return None, _end\n\n        # for the last \'friday\' of the month, for example\n        elif entry.startswith(\'l\'):\n            _assert(which == WEEK_OFFSET,\n                "you can only specify a leading \'L\' in the \'weekday\' field")\n            es, _, ee = entry[1:].partition(\'-\')\n            _assert((entry[1:].isdigit() and 0 <= int(es) <= 7) or\n                    (_ and es.isdigit() and ee.isdigit() and 0 <= int(es) <= 7 and 0 <= int(ee) <= 7),\n                "last <day> specifier must include a day number or range in the \'weekday\' field, you entered %r", entry)\n            return None, _end\n\n        # allow Sunday to be specified as weekday 7\n        if which == WEEK_OFFSET:\n            _end_limit = 7\n\n        increment = None\n        # increments\n        if \'/\' in entry:\n            entry, increment = entry.split(\'/\')\n            increment = int(increment, 10)\n            _assert(increment > 0,\n                "you can only use positive increment values, you provided %r",\n                increment)\n            _assert(increment <= _end_limit,\n                    "increment value must be less than %r, you provided %r",\n                    _end_limit, increment)\n\n        # handle singles and ranges\n        good = _parse_piece(entry)\n\n        # change Sunday to weekday 0\n        if which == WEEK_OFFSET and 7 in good:\n            good.discard(7)\n            good.add(0)\n\n        return good, _end\n\n\n_gv = lambda: str(random.randrange(60))\n\n\nclass CronTab(object):\n    __slots__ = \'matchers\', \'rs\'\n    def __init__(self, crontab, loop=False, random_seconds=False):\n        """\n        inputs:\n            `crontab` - crontab specification of "[S=0] Mi H D Mo DOW [Y=*]"\n            `loop` - do we loop when we validate / construct counts\n                     (turning 55-5,1 -> 0,1,2,3,4,5,55,56,57,58,59 in a "minutes" column)\n            `random_seconds` - randomly select starting second for tasks\n        """\n        self.rs = random_seconds\n        self.matchers = self._make_matchers(crontab, loop, random_seconds)\n\n    def __eq__(self, other):\n        if not isinstance(other, CronTab):\n            return False\n        match_last = self.matchers[1:] == other.matchers[1:]\n        return match_last and ((self.rs and other.rs) or (not self.rs and\n            not other.rs and self.matchers[0] == other.matchers[0]))\n\n    def _make_matchers(self, crontab, loop, random_seconds):\n        \'\'\'\n        This constructs the full matcher struct.\n        \'\'\'\n        crontab = _aliases.get(crontab, crontab)\n        ct = crontab.split()\n\n        if len(ct) == 5:\n            ct.insert(0, _gv() if random_seconds else \'0\')\n            ct.append(\'*\')\n        elif len(ct) == 6:\n            ct.insert(0, _gv() if random_seconds else \'0\')\n        _assert(len(ct) == 7,\n            "improper number of cron entries specified; got %i need 5 to 7"%(len(ct,)))\n\n        matchers = [_Matcher(which, entry, loop) for which, entry in enumerate(ct)]\n\n        return Matcher(*matchers)\n\n    def _test_match(self, index, dt):\n        \'\'\'\n        This tests the given field for whether it matches with the current\n        datetime object passed.\n        \'\'\'\n        at = _attribute[index]\n        attr = getattr(dt, at)\n        if index == WEEK_OFFSET:\n            attr = attr() % 7\n        return self.matchers[index](attr, dt)\n\n    def next(self, now=None, increments=_increments, delta=True, default_utc=WARN_CHANGE):\n        \'\'\'\n        How long to wait in seconds before this crontab entry can next be\n        executed.\n        \'\'\'\n        if default_utc is WARN_CHANGE and (isinstance(now, _number_types) or (now and not now.tzinfo) or now is None):\n            # warnings.warn(WARNING_CHANGE_MESSAGE, FutureWarning, 2)\n            default_utc = False\n\n        now = now or (datetime.utcnow() if default_utc and default_utc is not WARN_CHANGE else datetime.now())\n        if isinstance(now, _number_types):\n            now = datetime.utcfromtimestamp(now) if default_utc else datetime.fromtimestamp(now)\n\n        # handle timezones if the datetime object has a timezone and get a\n        # reasonable future/past start time\n        onow, now = now, now.replace(tzinfo=None)\n        tz = onow.tzinfo\n        future = now.replace(microsecond=0) + increments[0]()\n        if future < now:\n            # we are going backwards...\n            _test = lambda: future.year < self.matchers.year\n            if now.microsecond:\n                future = now.replace(microsecond=0)\n        else:\n            # we are going forwards\n            _test = lambda: self.matchers.year < future.year\n\n        # Start from the year and work our way down. Any time we increment a\n        # higher-magnitude value, we reset all lower-magnitude values. This\n        # gets us performance without sacrificing correctness. Still more\n        # complicated than a brute-force approach, but also orders of\n        # magnitude faster in basically all cases.\n        to_test = ENTRIES - 1\n        while to_test >= 0:\n            if not self._test_match(to_test, future):\n                inc = increments[to_test](future, self.matchers)\n                future += inc\n                for i in xrange(0, to_test):\n                    future = increments[ENTRIES+i](future, inc)\n                try:\n                    if _test():\n                        return None\n                except:\n                    print(future, type(future), type(inc))\n                    raise\n                to_test = ENTRIES-1\n                continue\n            to_test -= 1\n\n        # verify the match\n        match = [self._test_match(i, future) for i in xrange(ENTRIES)]\n        _assert(all(match),\n            "\\nYou have discovered a bug with crontab, please notify the\\n" \\\n            "author with the following information:\\n" \\\n            "crontab: %r\\n" \\\n            "now: %r", \' \'.join(m.input for m in self.matchers), now)\n\n        if not delta:\n            onow = now = datetime(1970, 1, 1)\n\n        delay = future - now\n        if tz:\n            delay += _fix_none(onow.utcoffset())\n            if hasattr(tz, \'localize\'):\n                delay -= _fix_none(tz.localize(future).utcoffset())\n            else:\n                delay -= _fix_none(future.replace(tzinfo=tz).utcoffset())\n\n        return delay.days * 86400 + delay.seconds + delay.microseconds / 1000000.\n\n    def previous(self, now=None, delta=True, default_utc=WARN_CHANGE):\n        return self.next(now, _decrements, delta, default_utc)\n\n    def test(self, entry):\n        if isinstance(entry, _number_types):\n            entry = datetime.utcfromtimestamp(entry)\n        for index in xrange(ENTRIES):\n            if not self._test_match(index, entry):\n                return False\n        return True\n\ndef _fix_none(d, _=timedelta(0)):\n    if d is None:\n        return _\n    return d\n')
    __stickytape_write_module('app/domain/services/parser/__init__.py', b'')
    __stickytape_write_module('app/domain/services/parser/cron_parser.py', b'import datetime as dt\n\nfrom app.domain.services.crontab import CronTab\nfrom app.domain.services.parser.i_parser import IParser\n\n\nclass CronParser(IParser):\n    def parse(self, message: str, now=None) -> dt.datetime:\n        if now is None:\n            now = dt.datetime.now()\n        crontab = CronTab(message)\n        seconds = crontab.next(now)\n        return now + dt.timedelta(seconds=seconds)\n')
    __stickytape_write_module('app/domain/services/parser/i_parser.py', b'import abc\nimport datetime as dt\n\n\nclass IParser(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def parse(self, time: str) -> dt.datetime:\n        pass\n')
    __stickytape_write_module('app/infrastructure/connector/__init__.py', b'')
    __stickytape_write_module('app/infrastructure/connector/db_cron_store.py', b"from typing import List\n\nfrom app.domain.services.cron.cron_store import CronStore\nfrom app.infrastructure.db.cron import Cron\nfrom app.infrastructure.db.db_session import transaction_context\nfrom app.infrastructure.log import logger\n\n\nclass DbCronStore(CronStore):\n    def is_cron(self, message: str) -> bool:\n        with transaction_context() as session:\n            r = session.query(Cron).filter_by(message=message).all()\n            if len(r) == 0:\n                return False\n            else:\n                return True\n\n    def get_all(self) -> List[Cron]:\n        with transaction_context() as session:\n            r = session.query(Cron).all()\n        return r\n\n    def remove_one(self, _id: int):\n        with transaction_context() as session:\n            r = session.query(Cron).filter_by(id=_id).first()\n            logger.info('Removing cron {}'.format(r.serialize))\n            session.delete(r)\n\n    def put(self, message: str, cron: str) -> Cron:\n        with transaction_context() as session:\n            entry = Cron(message=message, cron=cron)\n            session.add(entry)\n            session.commit()\n            logger.info('Cron added {}'.format(entry))\n        return entry\n\n    def get_one(self, message: str) -> str:\n        with transaction_context() as session:\n            result: Cron = session.query(Cron).filter_by(message=message).first()\n            result = result.serialize\n        return result\n\n\n")
    __stickytape_write_module('app/infrastructure/db/db_session.py', b'from contextlib import contextmanager\n\nfrom app.infrastructure.db import Session\n\n\n@contextmanager\ndef transaction_context():\n    session = Session()\n    session.expire_on_commit = False\n    try:\n        yield session\n        session.commit()\n    except:\n        raise\n    finally:\n        Session.remove()\n')
    __stickytape_write_module('app/infrastructure/log.py', b"import os\nimport logging\n\nfrom logging.handlers import RotatingFileHandler\nfrom logging import StreamHandler\n\nfrom app.infrastructure.config import app_config\n\n\ndef create_logger():\n    _logger = logging.getLogger(app_config.LOGGER_NAME)\n    _logger.setLevel(logging.INFO)\n    os.makedirs(app_config.LOG_FOLDER, exist_ok=True)\n    fh = RotatingFileHandler(app_config.LOG_FILE_PATH, maxBytes=10240, backupCount=10)\n    fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s [in %(pathname)s : %(lineno)d ]'\n    formatter = logging.Formatter(fmt)\n    fh.setFormatter(formatter)\n    _logger.addHandler(fh)\n    st = StreamHandler()\n    st.setFormatter(formatter)\n    _logger.addHandler(st)\n    return _logger\n\n\nlogger = create_logger()\n")
    __stickytape_write_module('app/domain/services/parser/parser.py', b'import datetime as dt\nfrom typing import Set\n\nfrom app.domain.services.parser.absolute_parser import AbsoluteParser\nfrom app.domain.services.parser.cron_parser import CronParser\nfrom app.domain.services.parser.i_parser import IParser\nfrom app.domain.services.parser.relative_parser import RelativeParser\nfrom app.infrastructure.log import logger\n\n\nclass Parser(IParser):\n    def __init__(self):\n        self.parsers: Set[IParser] = {CronParser(), RelativeParser(), AbsoluteParser()}\n\n    def parse(self, time: str) -> dt.datetime:\n        for parser in self.parsers:\n            try:\n                return parser.parse(time)\n            except Exception as e:\n                logger.info("Message {} couldn\'t be parsed with parser {}".format(time, parser.__class__.__name__))\n\n        raise Exception("Couldn\'t parse message {}", time)\n')
    __stickytape_write_module('app/domain/services/parser/absolute_parser.py', b"import datetime as dt\n\nfrom app.domain.services.parser.i_parser import IParser\n\n\nclass AbsoluteParser(IParser):\n    def parse(self, time: str) -> dt.datetime:\n        return dt.datetime.strptime(time, '%Y-%m-%d %H:%M')\n")
    __stickytape_write_module('app/domain/services/parser/relative_parser.py', b'import datetime as dt\nfrom collections import namedtuple\n\nfrom app.domain.services.parser.i_parser import IParser\n\nRelativeTime = namedtuple("RelativeTime", ["hours", "minutes", "seconds"])\n\n\nclass RelativeParser(IParser):\n    def __init__(self):\n        self.now = None\n\n    def parse(self, time: str, now=None) -> dt.datetime:\n        if now is None:\n            self.now = dt.datetime.now()\n        else:\n            self.now = now\n        r = self._parse(time)\n        return self.now + dt.timedelta(hours=r.hours, minutes=r.minutes, seconds=r.seconds)\n\n    def _parse(self, time: str) -> RelativeTime:\n        hours = 0\n        minutes = 0\n        seconds = 0\n        lst = time.split("h")\n        if len(lst) == 2:\n            hours = int(lst[0])\n            time = lst[1]\n        lst = time.split("m")\n        if len(lst) == 2:\n            minutes = int(lst[0])\n            time = lst[1]\n        lst = time.split("s")\n        if len(lst) == 2:\n            seconds = int(lst[0])\n        return RelativeTime(hours=hours, minutes=minutes, seconds=seconds)\n')
    __stickytape_write_module('app/domain/services/task_store.py', b'from abc import ABCMeta, abstractmethod\nfrom typing import List\n\nfrom app.domain.model.alert import Alert\n\n\nclass TaskStore(metaclass=ABCMeta):\n    @abstractmethod\n    def get_all(self) -> List[Alert]:\n        pass\n\n    @abstractmethod\n    def remove_one(self, _id: int):\n        pass\n\n    @abstractmethod\n    def put(self, alert: Alert) -> Alert:\n        pass\n\n    @abstractmethod\n    def alert_is_in_db(self, message: str, time: str) -> bool:\n        pass\n')
    __stickytape_write_module('app/infrastructure/connector/db_task_store.py', b"from dataclasses import asdict\nfrom typing import List\n\nfrom app.domain.model.alert import Alert\nfrom app.domain.services.task_store import TaskStore\nfrom app.infrastructure.db.alert import DbAlert\nfrom app.infrastructure.db.db_session import transaction_context\nfrom app.infrastructure.log import logger\n\n\nclass DbTaskStore(TaskStore):\n    def get_all(self) -> List[Alert]:\n        with transaction_context() as session:\n            r = session.query(DbAlert).all()\n            r = list(map(lambda x: Alert(**x.serialize), r))\n        return r\n\n    def remove_one(self, _id: int):\n        with transaction_context() as session:\n            r = session.query(DbAlert).filter_by(id=_id).first()\n            logger.info('Removing alert {}'.format(r.serialize))\n            session.delete(r)\n\n    def put(self, alert: Alert) -> Alert:\n        with transaction_context() as session:\n            entry = DbAlert(**asdict(alert))\n            session.add(entry)\n            session.commit()\n            alert = Alert(**entry.serialize)\n            logger.info('Alert added in DB : {}'.format(alert))\n        return alert\n\n    def alert_is_in_db(self, message: str, time: str) -> bool:\n        with transaction_context() as session:\n            r = session.query(DbAlert).filter_by(message=message).filter_by(time=time).all()\n            if len(r) == 0:\n                return False\n            else:\n                return True\n\n\n\n")
    __stickytape_write_module('app/interface/__init__.py', b'')
    __stickytape_write_module('app/interface/gui/__init__.py', b'')
    __stickytape_write_module('app/interface/gui/alert_window.py', b'from tkinter import *\nfrom threading import Thread\n\nfrom app.domain.model.alert import Alert\n\n\nclass AlertWindow(Thread):\n    def __init__(self, alert: Alert):\n        super().__init__()\n        self.daemon = True\n        self.alert: Alert = alert\n\n    def run(self) -> None:\n        root = Tk()\n        Label(root, text=self.alert.time).pack()\n        Label(root, text=self.alert.message).pack()\n        root.mainloop()\n')
    __stickytape_write_module('app/interface/gui/gui_launcher.py', b'from queue import Queue\nfrom threading import Thread\nfrom tkinter import Tk\n\nfrom app.interface.gui.main import Main\n\n\nclass GuiLauncher(Thread):\n    def __init__(self, in_queue: Queue, out_queue: Queue) -> None:\n        super().__init__()\n        self.daemon = True\n        self.in_queue = in_queue\n        self.out_queue = out_queue\n\n    def run(self) -> None:\n        root = Tk(baseName="Alerts")\n        Main(root, self.in_queue, self.out_queue).pack(side=\'top\', fill=\'both\', expand=True)\n        root.mainloop()\n')
    __stickytape_write_module('app/interface/gui/main.py', b'import queue\nimport tkinter as tk\nfrom typing import Dict\n\nfrom app.domain.model.alert import Alert\nfrom app.interface.gui.crontab_handler import CrontabHandler\nfrom app.interface.gui.input import Input\nfrom app.interface.gui.item import Item\nfrom app.interface.gui.navbar import Navbar\nfrom app.interface.gui.show_rule import ShowRule\n\n\nclass Main(tk.Frame):\n    def __init__(self, master, in_queue: queue.Queue, out_queue: queue.Queue, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n        self.in_queue = in_queue\n        self.out_queue = out_queue\n\n        self.navbar = Navbar(self)\n        self.navbar.pack(side="left", fill=\'y\')\n        self.main_frame = tk.Frame(self)\n        self.main_frame.pack(fill=\'both\', expand=True)\n        self.show_rule = ShowRule(self.main_frame)\n\n        self.crontab_frame = CrontabHandler(self.main_frame)\n\n        self.alert_frame = tk.Frame(self.main_frame)\n        self.alert_frame.pack()\n\n        self.input = Input(self.alert_frame)\n        self.input.pack()\n\n        self.items: Dict[int, Item] = {}\n\n        self.master.after(100, self.process_queue)\n\n    def process_queue(self):\n        while not self.in_queue.empty():\n            self.input.clear()\n            alert: Alert = self.in_queue.get()\n            if alert.id in self.items:\n                self.items[alert.id].destroy()\n                del self.items[alert.id]\n            else:\n                item = Item(self.alert_frame, alert.time, alert.message)\n                self.items[alert.id] = item\n                item.pack()\n        self.master.after(100, self.process_queue)\n\n    def switch_main(self, value):\n        if value == \'Alerts\':\n            self.crontab_frame.pack_forget()\n            self.show_rule.pack_forget()\n            self.alert_frame.pack()\n        elif value == \'CronTab\':\n            self.alert_frame.pack_forget()\n            self.show_rule.pack_forget()\n            self.crontab_frame.pack()\n            self.crontab_frame.refresh()\n        elif value == \'Cron rules\':\n            self.crontab_frame.pack_forget()\n            self.alert_frame.pack_forget()\n            self.show_rule.pack()\n')
    __stickytape_write_module('app/interface/gui/crontab_handler.py', b'from tkinter import *\nfrom typing import Dict\n\nfrom app.domain.services.cron.cron_service import CronService\nfrom app.interface.gui.cron_item import CronItem\n\n\nclass CrontabHandler(Frame):\n    cron_service: CronService\n\n    def __init__(self, master, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n        self.cron_service = CronService()\n        self.items: Dict[int, CronItem] = {}\n        CronItem(self, "Id", "Cron", "Message", title=True).pack()\n\n    def refresh(self):\n        lst = self.cron_service.get_all()\n        for cron in lst:\n            if cron.id not in self.items:\n                item = CronItem(self, cron.id, cron.cron, cron.message)\n                self.items[cron.id] = item\n                item.pack()\n\n    def remove_from_dict(self, _id):\n        del self.items[_id]\n')
    __stickytape_write_module('app/interface/gui/cron_item.py', b'from tkinter import *\n\nfrom app.domain.services.cron.cron_service import CronService\n\n\nclass CronItem(Frame):\n    cron_service: CronService\n\n    def __init__(self, master, id, time: str, message: str, title: bool = False, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n        self.cron_service = CronService()\n\n        self.id = id\n        self.time = time\n        self.message = message\n\n        Label(self, text=self.id).grid(row=0, column=0)\n        Label(self, text=self.time).grid(row=0, column=2)\n        Label(self, text=self.message).grid(row=0, column=4)\n        if not title:\n            Button(self, text="Delete", command=self.delete).grid(row=0, column=6)\n\n    def delete(self):\n        self.cron_service.remove_one(self.id)\n        self.master.remove_from_dict(self.id)\n        self.destroy()\n')
    __stickytape_write_module('app/interface/gui/input.py', b'from tkinter import *\n\n\nclass Input(Frame):\n    def __init__(self, master, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n\n        Label(self, text="time").grid(row=0, column=0)\n        Label(self, text="message").grid(row=0, column=5)\n        self.e1 = Entry(self)\n        self.e2 = Entry(self)\n        self.e1.grid(row=3, column=0)\n        self.e2.grid(row=3, column=5)\n\n        Button(self, text="Schedule !", command=self.schedule).grid(row=5, column=3)  # ,  sticky=W, pady=4)\n\n    def schedule(self):\n        self.master.master.master.out_queue.put((self.e1.get(), self.e2.get()))\n\n    def clear(self):\n        self.e1.delete(0, \'end\')\n        self.e2.delete(0, \'end\')\n')
    __stickytape_write_module('app/interface/gui/item.py', b'from tkinter import *\n\n\nclass Item(Frame):\n    def __init__(self, master, time: str, message: str, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n\n        Label(self, text=time).grid(row=0, column=0)\n        Label(self, text=message).grid(row=0, column=5)\n')
    __stickytape_write_module('app/interface/gui/navbar.py', b"from tkinter import *\n\n\nclass Navbar(Frame):\n    def __init__(self, master, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n        self.parent = master\n        self.lookup_table = {\n            '1': 'Alerts',\n            '2': 'CronTab',\n            '3': 'Cron rules'\n        }\n\n        Label(self, text='Navbar').pack()\n        self.var = IntVar(value=1)\n        Radiobutton(self, text='Alerts', variable=self.var, value=1, command=self.sel).pack()\n        Radiobutton(self, text='CronTab', variable=self.var, value=2, command=self.sel).pack()\n        Radiobutton(self, text='Cron rules', variable=self.var, value=3, command=self.sel).pack()\n\n    def sel(self):\n        self.parent.switch_main(self.lookup_table[str(self.var.get())])\n")
    __stickytape_write_module('app/interface/gui/show_rule.py', b"import os\nfrom tkinter import *\n\nfrom app.infrastructure.config import app_config\n\n\nclass ShowRule(Frame):\n    def __init__(self, master, cnf=None, **kw):\n        if cnf is None:\n            cnf = {}\n        super().__init__(master, cnf, **kw)\n\n        canvas = Canvas(self, width=700, height=400)\n        # self.img = PhotoImage(file=os.path.join(app_config.STATIC, 'crontab.gif'))\n        # canvas.create_image(20, 20, anchor=NW, image=self.img)\n        canvas.pack(fill='both', expand=True)\n")
    import asyncio
    import queue
    
    from app.domain.services.task_service import TaskService
    from app.infrastructure.log import logger
    from app.interface.gui.gui_launcher import GuiLauncher
    
    sync_queue = queue.Queue()
    out_sync_queue = queue.Queue()
    async_queue = asyncio.Queue()
    task_service = TaskService(sync_queue, async_queue)
    
    GuiLauncher(sync_queue, out_sync_queue).start()
    
    
    async def populate_queue():
        logger.info("populate_queue")
        while True:
            try:
                alert = out_sync_queue.get_nowait()
                await async_queue.put(alert)
            except queue.Empty:
                await asyncio.sleep(1)
    
    
    async def process():
        while True:
            await task_service.wait()
            await task_service.process_messages()
    
    
    loop = asyncio.get_event_loop()
    loop.create_task(populate_queue())
    loop.create_task(process())
    
    loop.run_forever()
    